% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/harmonization_fns.R
\name{dedup_values}
\alias{dedup_values}
\title{Deduplicate values within grouped data}
\usage{
dedup_values(
  data,
  id_col,
  date_col,
  value_col,
  method = c("mode", "first", "first_nonmissing")
)
}
\arguments{
\item{data}{A data frame or tibble containing the data to deduplicate.}

\item{id_col}{Column name identifying the grouping unit (e.g., individual, firm).}

\item{date_col}{Column name identifying the date or time grouping variable.}

\item{value_col}{Column name containing the values to deduplicate.}

\item{method}{A string specifying the deduplication method.
Must be one of \code{"mode"}, \code{"first"}, or \code{"first_nonmissing"}.}
}
\value{
A tibble with one row per unique combination of \code{id_col} and \code{date_col},
containing the deduplicated \code{value_col}.
}
\description{
This function deduplicates values within groups defined by a combination
of identifier and date columns. It provides three strategies:
\enumerate{
  \item \code{"mode"}: returns the most frequent (modal) value in the group.
  \item \code{"first"}: returns the first value in the group, even if \code{NA}.
  \item \code{"first_nonmissing"}: returns the first non-missing value in the group.
}
}
\details{
For \code{method = "mode"}, ties are broken arbitrarily by selecting the
first encountered maximum. Missing values are ignored when computing the mode.
}
\examples{
library(dplyr)

df <- tibble(
  id = c(1,1,1, 2,2,2, 3,3,3),
  date = c("2020-01","2020-01","2020-01",
           "2020-02","2020-02","2020-02",
           "2021-01","2021-01","2021-01"),
  gender = c("M","M","F", NA,"F","M", "M","F",NA)
)

dedup_values(df, id, date, gender, method = "mode")
dedup_values(df, id, date, gender, method = "first")
dedup_values(df, id, date, gender, method = "first_nonmissing")

}
